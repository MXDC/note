---
categories:
  - java
  - java虚拟机
  - java类加载机制
---
#### 虚拟机的类加载机制

虚拟机把描述类的数据从**Class文件（不一定是某个class文件，可以是任何形式的二进制字节流）**加载到内存，并对数据进行校验、转换解析和初始化，最终转换为虚拟机可以使用的java类型，这就是虚拟机的类加载机制。

#### 类加载过程

类从被加载到虚拟机内存开始，到卸载出内存位置，它的生命周期包括:加载（Loading）、验证(verification)、准备(Preparaton)、解析(Resolution)、初始化(Initialization)、使用和卸载(UnLoading)

![1568279230846.jpg](https://raw.githubusercontent.com/MXDC/images_bed/master/img/1568279230846.jpg)

> 些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。
>
> 其中解析阶段在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）



#### 加载（Loading）

在加载阶段，虚拟机需要完成以下3件事情：
**1）**通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

装载阶段主要是**将java字节码以二进制的方式读入到jvm内存中**，然后将二进制数据流按照字节码规范解析成jvm内部的运行时数据结构。java虚拟机规范只对字节码进行了规范，并没有对内部运行时数据结构进行规定，不同的jvm实现可以采用不同的数据结构，这些运行时数据结构是保存在jvm的方法区中。当一个类的二进制解析完毕后，jvm最终会生成一个java.lang.Class类型的实例对象，通过这个对象可以访问到该类在方法区的内容。

>Class对象比较特殊，它虽然是对象，但是存放在方法区里面.

#### 验证

从整体上看，验证阶段大致需要完成以下4个阶段的检验动作：

- 文件格式验证

  > 验证是否以魔数0xCAFEBABE开头,主、次版本号是否在当前虚拟机处理范围之内等等.....,验证字节流是否符合Class文件格式的规范，保证输入的字节流能正确的解析并存储于方法区之内，只有通过了这个阶段的验证后，字节流才会进入内存的方法区进行存储，后面3个验证阶段全部是基于方法区的存储结构进行的。

- 元数据验证

  > 对字节码描述的信息进行语义分析，以保证其描述的信息符合java语义规范的要求。如这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。这个类的父类是否继承了不允许被继承的类（被final修饰的类）。

- 字节码验证

  > 通过**数据流和控制流分析**，确定程序语义是合法的符合逻辑的，对类的方法进行校验分析，确保被验证类的方法在运行时不会做出危害虚拟机安全的事件。

- 符号引用验证

  > 发生在虚拟机将符合引用转化成直接引用的时候，动作发生在连接的第三个阶段**解析**，验证对类本身以外(常量池中的各种符号引用)的信息进行匹配性校验。如验证符号引用中通过字符串描述的全限定名是否能找到对应的类。

#### 准备

正式为类变量**分配内存**并设置**类变量初始值的阶段**，这些变量所使用的内存都将在方法区中进行分配。

- 内存分配只包括类变量(static)，而不包括实例变量，实例变量将会随着对象一起分配在java堆中

- 通常情况下数据类型赋值为零值，除非使用了**static final标示一个变量，才会在这一阶段直接赋值。**

  > public static int value = 10;//准备阶段过后初始值为0，而不是10，public static final int value = 10；//准备阶段过后初始值为10。主要是分配内存。

#### 解析



#### 初始化

