#### 归并排序

##### 思路1：

1. (递归地)将一个数组不断分成两半分别排序
2. 然后(递归地)将两个有序的数组**归并**成一个更大的有序数组

##### 思路2：

1. 先归并微小是数组，然后在成对的归并得到是子数组
2. 每个元素可以看为大小为1的数组，然后归并成两个，归并成四个，八个一直下去

---

##### 原地归并方法

**问题**：对于一个数组`a[lo..hi]`，将它两个子有序数组`a[lo..mid]`和`a[mid+1..hi]`归并成一个有序数组并将结果存放在数组`a[lo..hi]`中。

**思路**：

1. 先复制所有的元素到aux[]中。
2. 循环从aux[]的左右两个子数组`aux[lo..mid]`和`aux[mid+1..hi]`中取最小的元素到数组a中
3. 选取条件：
   * 先判断左半边或者右半边是否取完,因为左右子数组已经排序，如果有一边已经取完，直接取另一边的元素(左边用尽,取右边的元素;右边用尽,取左边的元素)
   
   * 如果子数组都没有取完，判断左边数组的当前元素和右边数组的当前元素，那个小就取那个元素

**原地归并代码实现**：

```java
    /**
     * 原地归并方法,将a[lo..mid] 和 a[mid+1..hi]归并
     * @param a 要归并的数组
     * @param lo 左边数组第一个值的索引
     * @param mid 左边数组最后一个值的索引
     * @param hi 右边数组最后一个值的索引
     */
    private static void merge(Comparable[] a, int lo, int mid, int hi){
        int i = lo, j = mid+1;
        for (int k = lo; k<=hi; k++) {
            //将a[lo..hi]复制到aux[lo..hi]
            aux[k] = a[k];
        }
        // 归并回到a[lo..hi]
        for (int k = lo; k<=hi; k++) {
            /** 左边数组取完*/
            if (i > mid){ a[k] = aux[j++]; }
            else if (j > hi) { a[k] = aux[i++]; }
            else if (less(aux[j],aux[i])) { a[k] = aux[j++]; }
            else { a[k] = aux[i++]; }
        }
    
```



##### 自顶向下的归并排序

##### 自底向上的归并排序


